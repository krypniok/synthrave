#define _GNU_SOURCE
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void *xmalloc(size_t sz) {
    void *ptr = malloc(sz);
    if (!ptr) {
        fprintf(stderr, "mid2sr: OOM\n");
        exit(EXIT_FAILURE);
    }
    return ptr;
}

static uint32_t read_be32(FILE *fp) {
    uint8_t buf[4];
    if (fread(buf, 1, 4, fp) != 4) {
        return 0;
    }
    return ((uint32_t)buf[0] << 24) |
           ((uint32_t)buf[1] << 16) |
           ((uint32_t)buf[2] << 8) |
           (uint32_t)buf[3];
}

static uint16_t read_be16(FILE *fp) {
    uint8_t buf[2];
    if (fread(buf, 1, 2, fp) != 2) {
        return 0;
    }
    return ((uint16_t)buf[0] << 8) | (uint16_t)buf[1];
}

static uint32_t read_varlen(FILE *fp) {
    uint32_t value = 0;
    uint8_t c = 0;
    do {
        if (fread(&c, 1, 1, fp) != 1) {
            return value;
        }
        value = (value << 7) | (c & 0x7F);
    } while (c & 0x80);
    return value;
}

static float note_to_hz(int note) {
    return 440.0f * powf(2.0f, (note - 69) / 12.0f);
}

static const char *program_to_token(uint8_t program) {
    static const char *table[] = {
        "PIANO","PIANO","PIANO","PIANO","PIANO","PIANO","PIANO","PIANO",
        "GUITAR","GUITAR","GUITAR","GUITAR","EGTR","EGTR","EGTR","EGTR",
        "BASS","BASS","SIDBASS","SIDBASS","FLUTE","FLUTE","FLUTE","FLUTE",
        "STRPAD","STRPAD","CHOIR","CHOIR","BRASS","BRASS","BRASS","BRASS",
        "LASER","ANALOGLEAD","CHIPARP","CHIPARP"
    };
    if (program < sizeof(table)/sizeof(table[0])) {
        return table[program];
    }
    return "PIANO";
}

static void write_header(FILE *out) {
    fputs("# Auto-generated by mid2sr (prototype)\n", out);
    fputs("# token , duration_ms [, gap_ms] [, mode] [, flags]\n", out);
}

static void convert_track(FILE *mid,
                          uint32_t track_size,
                          uint16_t division,
                          FILE *out) {
    long track_end = ftell(mid) + track_size;
    uint8_t running_status = 0;
    uint8_t program_per_channel[16] = {0};
    uint32_t current_tick = 0;

    while (ftell(mid) < track_end) {
        uint32_t delta = read_varlen(mid);
        current_tick += delta;
        uint8_t status = 0;
        if (fread(&status, 1, 1, mid) != 1) {
            break;
        }
        if (status < 0x80) {
            running_status = status;
            status = running_status;
        } else {
            running_status = status;
        }

        if (status == 0xFF) {
            uint8_t meta_type = 0;
            fread(&meta_type, 1, 1, mid);
            uint32_t len = read_varlen(mid);
            fseek(mid, len, SEEK_CUR);
            continue;
        }
        if (status == 0xF0 || status == 0xF7) {
            uint32_t len = read_varlen(mid);
            fseek(mid, len, SEEK_CUR);
            continue;
        }

        uint8_t type = status & 0xF0;
        uint8_t channel = status & 0x0F;
        uint8_t data1 = 0, data2 = 0;
        fread(&data1, 1, 1, mid);
        if (type != 0xC0 && type != 0xD0) {
            fread(&data2, 1, 1, mid);
        }

        if (type == 0x90 && data2 != 0) {
            float hz = note_to_hz(data1);
            const char *token = program_to_token(program_per_channel[channel]);
            fprintf(out, "%s@%.2f , %u , 10 , ,\n", token, hz, 300);
        } else if (type == 0xC0) {
            program_per_channel[channel] = data1;
        }
    }
    fseek(mid, track_end, SEEK_SET);
}

static void convert_midi(const char *mid_path, const char *aox_path) {
    FILE *mid = fopen(mid_path, "rb");
    if (!mid) {
        fprintf(stderr, "mid2sr: cannot open %s\n", mid_path);
        exit(EXIT_FAILURE);
    }
    char chunk[4];
    if (fread(chunk, 1, 4, mid) != 4 || memcmp(chunk, "MThd", 4) != 0) {
        fprintf(stderr, "mid2sr: invalid header\n");
        exit(EXIT_FAILURE);
    }
    uint32_t header_size = read_be32(mid);
    uint16_t format = read_be16(mid);
    uint16_t ntracks = read_be16(mid);
    uint16_t division = read_be16(mid);
    if (header_size > 6) {
        fseek(mid, header_size - 6, SEEK_CUR);
    }

    FILE *out = fopen(aox_path, "w");
    if (!out) {
        fprintf(stderr, "mid2sr: cannot open %s for writing\n", aox_path);
        exit(EXIT_FAILURE);
    }
    write_header(out);

    for (uint16_t t = 0; t < ntracks; ++t) {
        if (fread(chunk, 1, 4, mid) != 4 || memcmp(chunk, "MTrk", 4) != 0) {
            fprintf(stderr, "mid2sr: missing track chunk\n");
            break;
        }
        uint32_t track_size = read_be32(mid);
        convert_track(mid, track_size, division, out);
    }

    fclose(out);
    fclose(mid);
}

int main(int argc, char **argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s input.mid output.aox\n", argv[0]);
        return 1;
    }
    convert_midi(argv[1], argv[2]);
    return 0;
}
